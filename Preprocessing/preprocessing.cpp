#include "preprocessing.h"

Mat hough_transform(Mat image)
{

  //Variables to write the radius and center position on the screen.
  string radiusStr;
  string xcenterStr;
  string ycenterStr;
  int Rvalue;
  int Xvalue;
  int Yvalue;

  // Open the original colored image and convert to a grayscaled image
  Mat coloredimage;
  Mat grayimage;

  //vector to store the center value ( x and y coordinates ) and the radius of each detected circle
  vector<Vec3f> circles;

  //Open and resize the colored image.
  coloredimage = image;

  //convert colored image to gray scale
  cvtColor(coloredimage, grayimage, CV_BGR2GRAY);

  // Apply blur to Reduce the noise to avoid false detections.
  GaussianBlur(grayimage, grayimage, Size(9, 9), 2, 2);

  // Apply the Hough Transform to find the circles (use the gray scale image as input)
  //Arguments: 1: input image( grayscaled ) . 2: vector to tore the circle parameters .3: detection method,
  // 4: inverse ratio of resolution . 5 minimum distance between detected centers. 6: upper threshold for the internal canny edge detector
  //7: threshold for center detection . 8: Minimum radius to be detected (0=unknown) . 9: maximum radius to be detected
  HoughCircles(grayimage, circles, CV_HOUGH_GRADIENT, 1, 30, 200, 50, 0, 0);


  // Draw the circles detected
  for (size_t i = 0; i < circles.size(); i++)
  {
    //Get the informations from the circles vector generated by the function HoughCircles. 
    //X center coordinate is circles[i][0]  , Y center coordinate is circles[i][1] , radius is circles[i][2] 
    Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
    int radius = cvRound(circles[i][2]);

    //Store these values into variables to be converted into string and displayed on the image
    Rvalue = radius;
    Xvalue = cvRound(circles[i][0]);
    Yvalue = cvRound(circles[i][1]);

    //DRAWING THE CENTER OF THE CIRCLE
    //Use the circle function to draw the center of the detected circle
    //Use the center coordinate and a radius of 3 to just draw a point on the center.
    circle(coloredimage, center, 3, Scalar(0, 255, 0), -1, 8, 0);

    //DRAWING THE CIRCLE CONTOUR.
    //Use the circle function to draw the detected circle on the image
    //Use the center coordinate and the radius coordinate detected by the HoughCircles function
    circle(coloredimage, center, radius, Scalar(0, 0, 255), 3, 8, 0);

    //Convert the integer Center point and radius values to string
    radiusStr = intToString(Rvalue);
    xcenterStr = intToString(Xvalue);
    ycenterStr = intToString(Yvalue);

    //Display on the colored image the center and radius values.
    putText(coloredimage, "(" + xcenterStr + "," + ycenterStr + ")", Point(Xvalue, Yvalue - 20), 1, 1, Scalar(0, 255, 0), 2);

    cout << "radius:" << radiusStr << "    Column:" << xcenterStr << "    Row:" << ycenterStr;
  }

  return coloredimage;

}


void hough_transform_from_video(string name_video)
{
	//Varibles to store and show the detected circle properties
	string radiusStr;
	string xcenterStr;
	string ycenterStr;
	int Rvalue;
	int Xvalue;
	int Yvalue;

	//Variables to store  from the video , and a converted version of the video
	Mat coloredimage;
	Mat grayimage;
	Mat binaryimage;

	//auxiliar variable to quit the loop and end the program
	char key = 0;

	//Open the default camera
	VideoCapture capture(name_video);

	//Check for Failure
	if (!capture.isOpened())
	{
		printf("Failed to open the video");
	}

	//Set Capture device properties.

	capture.set(CV_CAP_PROP_FRAME_WIDTH, 640);
	capture.set(CV_CAP_PROP_FRAME_HEIGHT, 480);

	//for(int i=0; i<44*30; ++i)
	//		capture >> coloredimage;

	//Loop will stop if "q" is pressed in the keyboard
	while (key != 'q')
	{

		//Capture a frame of the webcam live video and store it on the image variable
		capture >> coloredimage;

		//Resize this frame and convert to gray scale
		cvtColor(coloredimage, grayimage, CV_BGR2GRAY);
		//imshow("Gray Image", grayimage);


		// Apply blur to Reduce the noise so we avoid false circle detection
		GaussianBlur(grayimage, grayimage, Size(9, 9), 2, 2);

		/*Apply threshhold to the image*/
		//threshold( grayimage, binaryimage, 100, 255, THRESH_BINARY );
  		adaptiveThreshold(grayimage, binaryimage, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY,11,3);
  		imshow("Binarized Image", binaryimage);

		//binaryimage = threshold_to_zero(grayimage);
		//binaryimage = inverse_binary_thresholding(binaryimage);
		
		//create a vector to store the center value ( x and y coordinates ) and the radius of each detected circle
		vector<Vec3f> circles;


		// Apply the Hough Transform to find the circles (use the gray scale image as input)
		//Arguments: 1: input image( grayscaled ) . 2: vector to tore the circle parameters .3: detection method,
		// 4: inverse ratio of resolution . 5 minimum distance between detected centers. 6: upper threshold for the internal canny edge detector
		//7: threshold for center detection . 8: Minimum radius to be detected (0=unknown) . 9: maximum radius to be detected

		//HoughCircles(grayimage, circles, CV_HOUGH_GRADIENT, 1, 30, 200, 50, 0, 0);
		HoughCircles(binaryimage, circles, CV_HOUGH_GRADIENT, 2, 30, 128, 50, 0, 40);
		Mat drawing = Mat::zeros( binaryimage.size(), CV_8UC3 );
		
		// Draw the circles detected
		for (size_t i = 0; i < circles.size(); i++)
		{

			//Get the informations from the circles vector generated by the function HoughCircles. 
			//Column is circles[i][0]  , Row is circles[i][1] , radius is circles[i][2] 
			Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
			int radius = cvRound(circles[i][2]);

			//Store these values into variables to be converted into string and displayed on the image
			Rvalue = radius;
			Xvalue = cvRound(circles[i][0]);
			Yvalue = cvRound(circles[i][1]);

			//DRAWING THE CENTER OF THE CIRCLE
			//Use the circle function to draw the center of the detected circle
			//Use the center coordinate and a radius of 3 to just draw a point on the center.
			circle(drawing, center, 3, Scalar(113, 6, 255), -1, 8, 0);

			//DRAWING THE CIRCLE CONTOUR.
			//Use the circle function to draw the detected circle on the image
			//Use the center coordinate and the radius coordinate detected by the HoughCircles function
			circle(drawing, center, radius, Scalar(113, 6, 255), 3, 8, 0);

			//Convert the integer Center point and radius values to string
			//radiusStr = intToString(Rvalue);
			//xcenterStr = intToString(Xvalue);
			//ycenterStr = intToString(Yvalue);

			//Display on the colored image the center and radius values.
			//putText(coloredimage, "(" + xcenterStr + "," + ycenterStr + ")", Point(Xvalue, Yvalue-20), 1, 1, Scalar(0, 255, 0), 2);

			//Display the values also on the cmd window
			cout << "center : " << center << "\nradius : " << radius << endl;

		}

		namedWindow("Hough Circle Transform", CV_WINDOW_AUTOSIZE);
		imshow("Hough Circle Transform", drawing);

		key = waitKey(30);

	}
}


void find_rings(string name_video)
{

	//Variables to store  from the video , and a converted version of the video
	Mat coloredimage;
	Mat grayimage;
	Mat threshold_output; // binarized image
  	vector<vector<Point> > contours; //contours (elipses)
  	vector<Vec4i> hierarchy; // 
  	Mat drawing;
  	Scalar color;


  	float x_t0, y_t0;
  	float x_t1, y_t1;
  	float holgura = 1;
  	float distance;
  	int counter = 0;


	//auxiliar variable to quit the loop and end the program
	char key = 0;
	
	//Capturing the video scene: 0 webcam, 1 other camera
	VideoCapture capture(name_video);
	
	//Check for Failure
	if (!capture.isOpened())
	{
		printf("Failed to open the video");
	}

	//Set Capture device properties.
	capture.set(CV_CAP_PROP_FRAME_WIDTH, 640);
	capture.set(CV_CAP_PROP_FRAME_HEIGHT, 480);

	//for(int i=0; i<44*30; ++i)
	//	capture >> coloredimage;

	//Loop will stop if "q" is pressed in the keyboard
	while (key != 'q')
	{

		//Capture a frame of the webcam live video and store it on the image variable
		capture >> coloredimage;
		

		//Resize this frame and convert to gray scale
		cvtColor(coloredimage, grayimage, CV_BGR2GRAY);
		GaussianBlur(grayimage, grayimage, Size(9, 9), 2, 2);

		/// Detect edges using Threshold
		//threshold( grayimage, threshold_output, 100, 255, THRESH_BINARY );
  		adaptiveThreshold(grayimage, threshold_output, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY,11,3);
  		imshow("Binarized Image", threshold_output);

  		
  		/// Find contours
  		findContours( threshold_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );

		/// Find the  ellipses for each contour
		vector<RotatedRect> minEllipse( contours.size() );

  		for( unsigned int i = 0; i < contours.size(); i++ )
     	{ 
     		
       		if( contours[i].size() > 5 )
         	{ 
         		minEllipse[i] = fitEllipse( Mat(contours[i]) ); 
         	}
     	}

  		/// Draw contours + rotated rects + ellipses
  		drawing = Mat::zeros( threshold_output.size(), CV_8UC3 );
  		cout <<"number of elipses: "<<contours.size()<<endl;
  		
  		for( unsigned int i = 0; i< contours.size()-1; i++ )
     	{
       		color = Scalar( 113, 6, 255 );
       		
       		// contour
       		//drawContours( drawing, contours, i, color, 1, 8, vector<Vec4i>(), 0, Point() );
       		
       		// ellipse
       		x_t0 = minEllipse[i].center.x;
       		y_t0 = minEllipse[i].center.y;

       		x_t1 = minEllipse[i+1].center.x;
       		y_t1 = minEllipse[i+1].center.y;
            
       		distance = sqrt(pow(x_t0 - x_t1, 2) + pow(y_t0 - y_t1, 2));

       		if(distance <= holgura)
	       	{
	       		ellipse( drawing, minEllipse[i], color, 2, 8 );
	       		ellipse( drawing, minEllipse[i+1], color, 2, 8 );
	       		counter++;
	       	}
     	}

     	cout<<"Number of ellipses: "<<counter<<endl;
     	counter = 0;

     	namedWindow("Ellipses method", CV_WINDOW_AUTOSIZE);
		imshow("Ellipses method", drawing);

		key = waitKey(30);

	}

}